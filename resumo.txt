REF.: https://github.com/alura-cursos/Kubernetes-Istio
Iniciamos com a nossa aplicação base, uma aplicação em Node.js, que faz uma requisição para o WorldTimeAPI.org para obter um JSON de data e hora.
Colocamos essa aplicação dentro de um cluster do Minikube e, em seguida, instalamos o Istio no Minikube. Também configuramos os logs do Istio, permitindo que ele coletasse logs. É importante lembrar que esses logs são úteis para resolver problemas de conexão, mas podem se tornar muito grandes em ambientes de produção, então é necessário ter cuidado.
Depois, exploramos as Destination Rules (regras de destino), onde mostramos ao Istio quais são os nossos serviços, incluindo o serviço de produção e o serviço Canary, e definimos o tipo de comunicação e o nível de criptografia que o Istio deve utilizar.
Seguimos com o Gateway de entrada, o Ingress Gateway, onde criamos o Gateway, que preparou um Ingress Controller com todas as configurações necessárias para acessar nossa aplicação. Utilizamos também o Routing e os serviços virtuais do Istio para realizar o roteamento da nossa aplicação, indicando ao Istio para onde enviar as requisições e pacotes.
A partir do Routing, conseguimos testar nossa aplicação e verificamos que ela funcionava tão bem quanto dentro do Kubernetes. Em seguida, fizemos melhorias, adicionando Retries no nosso Routing, permitindo que o Istio tentasse novas requisições caso encontrasse algum problema.
Para monitorar o que estava acontecendo, utilizamos o Kiali, um dashboard que mostra todo o caminho das nossas requisições, passando pelo nosso Ingress Gateway, serviço de Front-end, Midware, Back-end e saindo para o WorldTimeAPI.
Com tudo isso, já tínhamos uma aplicação robusta, mas também trabalhamos melhorando a segurança da aplicação.
Bloqueamos conexões externas à aplicação, a menos que estivessem na nossa lista de saída, onde criamos um Service Entry com o WorldTimeAPI. Verificamos se ele estava funcionando corretamente e, ao bloquear conexões para a Alura e para o Google, conseguimos manter a conexão com nosso serviço.
Depois, passamos para a parte de Canary e Beta Testing, começando com a parte de Canary. Adicionamos um header que, se presente, permitia ao usuário acessar a versão Canary da aplicação, a nova versão da nossa aplicação de Midware, possibilitando iniciar testes de uma nova versão da aplicação. Em seguida, removemos a versão Canary e passamos para o Rolling Release, onde definimos qual porcentagem dos usuários utilizaria a nova versão da aplicação.
